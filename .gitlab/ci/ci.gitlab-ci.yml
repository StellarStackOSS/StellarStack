# CI Pipeline — runs on all branches and merge requests
# Uses Turborepo for caching and parallel task execution

# ─── Install ────────────────────────────────────────────────────────
install:
  extends:
    - .node-setup
    - .ci-rules
  stage: install
  cache:
    - key:
        files:
          - pnpm-lock.yaml
      paths:
        - node_modules/
        - apps/*/node_modules/
        - packages/*/node_modules/
      policy: pull-push
    - key: turbo-${CI_COMMIT_REF_SLUG}
      paths:
        - .turbo/
      policy: pull-push
  script:
    - pnpm install --frozen-lockfile

# ─── Pre-build (typecheck + lint via Turbo) ──────────────────────
pre-build:
  extends:
    - .node-setup
    - .ci-rules
  stage: pre-build
  tags: [saas-linux-2xlarge-amd64]
  needs: [install]
  script:
    - pnpm turbo typecheck lint --env-mode=loose

# ─── Build (all apps via Turbo) ──────────────────────────────────
build:
  extends:
    - .node-setup
    - .ci-rules
  stage: build
  tags: [saas-linux-2xlarge-amd64]
  needs: [pre-build]
  script:
    - pnpm turbo build --env-mode=loose

# ─── Test (jsdom — packages/ui) ────────────────────────────────────
test-jsdom:
  extends:
    - .node-setup
    - .ci-rules
  stage: test
  needs: [build]
  script:
    - pnpm test:jsdom

# ─── Test (happy-dom — apps/web) ───────────────────────────────────
test-dom:
  extends:
    - .node-setup
    - .ci-rules
  stage: test
  needs: [build]
  script:
    - pnpm test:dom

# ─── Test (node — apps/api) ────────────────────────────────────────
test-node:
  extends:
    - .node-setup
    - .ci-rules
  stage: test
  needs: [build]
  script:
    - pnpm test:node

# ─── Code Analysis ─────────────────────────────────────────────────
code-analysis:
  extends:
    - .node-setup
    - .ci-rules
  stage: analysis
  needs: [test-jsdom, test-dom, test-node]
  script:
    - pnpm jscpd --pattern "apps/api/src/**/*.ts" --pattern "apps/web/**/*.{ts,tsx}" --pattern "apps/home/**/*.{ts,tsx}" --pattern "packages/ui/src/**/*.{ts,tsx}" --ignore "**/node_modules/**" --ignore "**/.next/**" --ignore "**/dist/**" --ignore "**/stories/**" --threshold 5
    - pnpm format:check

# ─── Railway + Cloudflare helper functions ─────────────────────────
# Railway GraphQL API for environment/service management
# Cloudflare API for DNS record management
# Each environment gets its own Postgres + Redis instances via Railway.
#
# Required CI variables:
#   RAILWAY_API_TOKEN       — Railway API token
#   RAILWAY_PROJECT_ID      — Railway project ID
#   CLOUDFLARE_API_TOKEN    — Cloudflare API token (DNS edit)
#   CLOUDFLARE_ZONE_ID_DEV  — Zone ID for stellarstack.dev
#   BETTER_AUTH_SECRET      — Auth secret for API

.railway-deploy-script: &railway-deploy-script
  - npm install -g @railway/cli
  - apt-get update -qq && apt-get install -yqq jq > /dev/null
  - SLUG=$(echo "$CI_COMMIT_REF_SLUG" | cut -c1-30)
  - RAILWAY_API="https://backboard.railway.com/graphql/v2"

  # ── Railway GraphQL helper ──
  - |
    railway_gql() {
      RESPONSE=$(curl -s -X POST "$RAILWAY_API" \
        -H "Authorization: Bearer $RAILWAY_API_TOKEN" \
        -H "Content-Type: application/json" \
        -d "$1")
      ERRORS=$(echo "$RESPONSE" | jq -r '.errors[0].message // empty' 2>/dev/null)
      if [ -n "$ERRORS" ]; then
        echo "Railway API error: $ERRORS" >&2
      fi
      echo "$RESPONSE"
    }

  # ── Environment management ──
  - |
    get_env_id() {
      railway_gql "{\"query\":\"{ environments(projectId: \\\"$RAILWAY_PROJECT_ID\\\") { edges { node { id name } } } }\"}" \
        | jq -r "(.data.environments.edges // [])[] | select(.node.name == \"$1\") | .node.id"
    }
  - |
    delete_env() {
      ENV_ID=$(get_env_id "$1")
      if [ -n "$ENV_ID" ]; then
        railway_gql "{\"query\":\"mutation { environmentDelete(id: \\\"$ENV_ID\\\") }\"}" > /dev/null
        echo "Deleted environment $1"
      fi
    }
  - |
    create_env() {
      railway_gql "{\"query\":\"mutation { environmentCreate(input: { name: \\\"$1\\\", projectId: \\\"$RAILWAY_PROJECT_ID\\\" }) { id name } }\"}" \
        | jq -r '.data.environmentCreate.id'
    }

  # ── Service management ──
  - |
    get_service_id() {
      # $1 = service name
      railway_gql "{\"query\":\"{ project(id: \\\"$RAILWAY_PROJECT_ID\\\") { services { edges { node { id name } } } } }\"}" \
        | jq -r "(.data.project.services.edges // [])[] | select(.node.name == \"$1\") | .node.id"
    }
  - |
    list_services() {
      # Debug helper — lists all service names in the project
      railway_gql "{\"query\":\"{ project(id: \\\"$RAILWAY_PROJECT_ID\\\") { services { edges { node { id name } } } } }\"}" \
        | jq -r '(.data.project.services.edges // [])[] | .node.name'
    }
  - |
    ensure_service() {
      # $1 = service name — returns existing or newly created service ID
      SVC_ID=$(get_service_id "$1")
      if [ -n "$SVC_ID" ]; then
        echo "$SVC_ID"
        return
      fi
      echo "Creating service: $1" >&2
      railway_gql "{\"query\":\"mutation { serviceCreate(input: { name: \\\"$1\\\", projectId: \\\"$RAILWAY_PROJECT_ID\\\" }) { id } }\"}" \
        | jq -r '.data.serviceCreate.id'
    }
  - |
    ensure_database_service() {
      # $1 = service name, $2 = Docker image (e.g., postgres:16, redis:7)
      SVC_ID=$(get_service_id "$1")
      if [ -n "$SVC_ID" ]; then
        echo "$SVC_ID"
        return
      fi
      echo "Creating database service: $1 ($2)" >&2
      railway_gql "{\"query\":\"mutation { serviceCreate(input: { name: \\\"$1\\\", projectId: \\\"$RAILWAY_PROJECT_ID\\\", source: { image: \\\"$2\\\" } }) { id } }\"}" \
        | jq -r '.data.serviceCreate.id'
    }

  # ── Variable management ──
  - |
    set_service_var() {
      # $1 = service ID, $2 = environment ID, $3 = var name, $4 = var value
      railway_gql "{\"query\":\"mutation { variableUpsert(input: { projectId: \\\"$RAILWAY_PROJECT_ID\\\", serviceId: \\\"$1\\\", environmentId: \\\"$2\\\", name: \\\"$3\\\", value: \\\"$4\\\" }) }\"}" > /dev/null
    }

  # ── Custom domain management ──
  - |
    add_custom_domain() {
      # $1 = service ID, $2 = environment ID, $3 = domain
      railway_gql "{\"query\":\"mutation { customDomainCreate(input: { projectId: \\\"$RAILWAY_PROJECT_ID\\\", serviceId: \\\"$1\\\", environmentId: \\\"$2\\\", domain: \\\"$3\\\" }) { id domain } }\"}"
    }
  - |
    ensure_service_domain() {
      # $1 = service ID, $2 = environment ID
      # Returns existing Railway domain or creates one
      DOMAIN=$(railway_gql "{\"query\":\"{ domains(projectId: \\\"$RAILWAY_PROJECT_ID\\\", serviceId: \\\"$1\\\", environmentId: \\\"$2\\\") { serviceDomains { domain } } }\"}" \
        | jq -r '.data.domains.serviceDomains[0].domain // empty')
      if [ -z "$DOMAIN" ]; then
        DOMAIN=$(railway_gql "{\"query\":\"mutation { serviceDomainCreate(input: { serviceId: \\\"$1\\\", environmentId: \\\"$2\\\" }) { domain } }\"}" \
          | jq -r '.data.serviceDomainCreate.domain')
      fi
      echo "$DOMAIN"
    }

  # ── Cloudflare DNS helpers ──
  - |
    create_cf_record() {
      # $1 = subdomain, $2 = CNAME target, $3 = zone ID
      curl -sf -X POST "https://api.cloudflare.com/client/v4/zones/${3}/dns_records" \
        -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"type\":\"CNAME\",\"name\":\"$1\",\"content\":\"$2\",\"proxied\":true}" \
        | jq -r '.result.id'
    }
  - |
    delete_cf_record() {
      # $1 = full domain name, $2 = zone ID
      RECORD_ID=$(curl -sf "https://api.cloudflare.com/client/v4/zones/${2}/dns_records?name=$1" \
        -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
        | jq -r '.result[0].id // empty')
      if [ -n "$RECORD_ID" ]; then
        curl -sf -X DELETE "https://api.cloudflare.com/client/v4/zones/${2}/dns_records/${RECORD_ID}" \
          -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" > /dev/null
        echo "Deleted DNS record: $1"
      fi
    }

  # ── Full-stack deploy orchestrator ──
  - |
    deploy_full_stack() {
      # $1 = env name (e.g., dev-slug), $2 = slug
      echo "=== Ensuring environment: $1 ==="
      ENV_ID=$(get_env_id "$1")
      if [ -n "$ENV_ID" ]; then
        echo "Reusing existing environment: $ENV_ID"
      else
        ENV_ID=$(create_env "$1")
        if [ -z "$ENV_ID" ] || [ "$ENV_ID" = "null" ]; then
          echo "ERROR: Failed to create environment '$1'" >&2
          return 1
        fi
        echo "Created environment: $ENV_ID"
      fi

      echo "=== Ensuring all services exist ==="
      list_services
      API_SVC_ID=$(ensure_service "api")
      WEB_SVC_ID=$(ensure_service "web")
      DAEMON_SVC_ID=$(ensure_service "mock-daemon")
      PG_SVC_ID=$(ensure_database_service "Postgres" "postgres:16")
      REDIS_SVC_ID=$(ensure_database_service "Redis" "redis:7")
      echo "API=$API_SVC_ID  WEB=$WEB_SVC_ID  DAEMON=$DAEMON_SVC_ID  PG=$PG_SVC_ID  REDIS=$REDIS_SVC_ID"

      if [ -z "$API_SVC_ID" ] || [ -z "$WEB_SVC_ID" ] || [ -z "$DAEMON_SVC_ID" ] || [ -z "$PG_SVC_ID" ] || [ -z "$REDIS_SVC_ID" ]; then
        echo "ERROR: Failed to ensure all services exist" >&2
        list_services
        return 1
      fi

      echo "=== Configuring Postgres + Redis ==="
      set_service_var "$PG_SVC_ID" "$ENV_ID" "POSTGRES_PASSWORD" "stellar"
      set_service_var "$PG_SVC_ID" "$ENV_ID" "POSTGRES_USER" "stellar"
      set_service_var "$PG_SVC_ID" "$ENV_ID" "POSTGRES_DB" "stellar"

      PANEL_URL="https://${2}-panel.stellarstack.dev"
      API_URL="https://${2}-api.stellarstack.dev"
      DAEMON_URL="https://${2}-daemon.stellarstack.dev"

      # Use Railway reference variables — resolved at deploy time to the
      # per-environment Postgres/Redis instances automatically
      echo "=== Setting API environment variables ==="
      set_service_var "$API_SVC_ID" "$ENV_ID" "DATABASE_URL" "\${{Postgres.DATABASE_URL}}"
      set_service_var "$API_SVC_ID" "$ENV_ID" "REDIS_URL" "\${{Redis.REDIS_URL}}"
      set_service_var "$API_SVC_ID" "$ENV_ID" "FRONTEND_URL" "$PANEL_URL"
      set_service_var "$API_SVC_ID" "$ENV_ID" "API_URL" "$API_URL"
      set_service_var "$API_SVC_ID" "$ENV_ID" "BETTER_AUTH_SECRET" "$BETTER_AUTH_SECRET"
      set_service_var "$API_SVC_ID" "$ENV_ID" "NODE_ENV" "production"
      set_service_var "$API_SVC_ID" "$ENV_ID" "PORT" "3001"

      echo "=== Setting Web environment variables ==="
      set_service_var "$WEB_SVC_ID" "$ENV_ID" "NEXT_PUBLIC_API_URL" "$API_URL"
      set_service_var "$WEB_SVC_ID" "$ENV_ID" "NEXT_PUBLIC_WS_URL" "wss://${2}-api.stellarstack.dev"
      set_service_var "$WEB_SVC_ID" "$ENV_ID" "NEXT_PUBLIC_DAEMON_URL" "$DAEMON_URL"

      echo "=== Setting Mock Daemon environment variables ==="
      set_service_var "$DAEMON_SVC_ID" "$ENV_ID" "PORT" "8080"

      echo "=== Deploying services ==="
      railway up --project "$RAILWAY_PROJECT_ID" --service api --environment "$1" --detach
      railway up --project "$RAILWAY_PROJECT_ID" --service web --environment "$1" --detach
      railway up --project "$RAILWAY_PROJECT_ID" --service mock-daemon --environment "$1" --detach

      echo "=== Waiting for service domains to register ==="
      sleep 10

      echo "=== Setting up custom domains + DNS ==="
      API_RAILWAY_DOMAIN=$(ensure_service_domain "$API_SVC_ID" "$ENV_ID")
      WEB_RAILWAY_DOMAIN=$(ensure_service_domain "$WEB_SVC_ID" "$ENV_ID")
      DAEMON_RAILWAY_DOMAIN=$(ensure_service_domain "$DAEMON_SVC_ID" "$ENV_ID")
      echo "Railway domains: API=$API_RAILWAY_DOMAIN  WEB=$WEB_RAILWAY_DOMAIN  DAEMON=$DAEMON_RAILWAY_DOMAIN"

      create_cf_record "${2}-api.stellarstack.dev" "$API_RAILWAY_DOMAIN" "$CLOUDFLARE_ZONE_ID_DEV"
      create_cf_record "${2}-panel.stellarstack.dev" "$WEB_RAILWAY_DOMAIN" "$CLOUDFLARE_ZONE_ID_DEV"
      create_cf_record "${2}-daemon.stellarstack.dev" "$DAEMON_RAILWAY_DOMAIN" "$CLOUDFLARE_ZONE_ID_DEV"

      add_custom_domain "$API_SVC_ID" "$ENV_ID" "${2}-api.stellarstack.dev"
      add_custom_domain "$WEB_SVC_ID" "$ENV_ID" "${2}-panel.stellarstack.dev"
      add_custom_domain "$DAEMON_SVC_ID" "$ENV_ID" "${2}-daemon.stellarstack.dev"

      echo "========================================="
      echo "  Panel  → $PANEL_URL"
      echo "  API    → $API_URL"
      echo "  Daemon → $DAEMON_URL"
      echo "========================================="
    }

  # ── Full-stack cleanup orchestrator ──
  - |
    cleanup_full_stack() {
      # $1 = env name, $2 = slug
      echo "=== Cleaning up DNS records ==="
      delete_cf_record "${2}-api.stellarstack.dev" "$CLOUDFLARE_ZONE_ID_DEV"
      delete_cf_record "${2}-panel.stellarstack.dev" "$CLOUDFLARE_ZONE_ID_DEV"
      delete_cf_record "${2}-daemon.stellarstack.dev" "$CLOUDFLARE_ZONE_ID_DEV"

      echo "=== Deleting Railway environment ==="
      delete_env "$1"

      echo "Cleanup complete for $1"
    }

# ─── Deploy Dev (Railway — manual) ────────────────────────────────
deploy-dev:
  stage: deploy
  image: node:${NODE_VERSION}
  needs: []
  script:
    - *railway-deploy-script
    - deploy_full_stack "dev-${SLUG}" "${SLUG}"
  environment:
    name: dev/$CI_COMMIT_REF_SLUG
    url: https://${CI_COMMIT_REF_SLUG}-panel.stellarstack.dev
    on_stop: cleanup-dev
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH
      when: manual
      allow_failure: true

# ─── Cleanup Dev ──────────────────────────────────────────────────
cleanup-dev:
  stage: cleanup
  image: node:${NODE_VERSION}
  variables:
    GIT_STRATEGY: none
  script:
    - *railway-deploy-script
    - cleanup_full_stack "dev-${SLUG}" "${SLUG}"
  environment:
    name: dev/$CI_COMMIT_REF_SLUG
    action: stop
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH
      when: manual
      allow_failure: true
